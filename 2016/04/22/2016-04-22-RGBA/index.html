<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>UIImage与RGBA、BGR、GrayScale | 彩笔</title><meta name="description"><meta name="generator" content="彩笔"><meta name="author" content="Color Pen"><meta name="keywords"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1><a href="/" alt="彩笔" title="彩笔" itemprop="headline">彩笔</a></h1><p itemprop="description">眼中阅尽繁华，心中鲜衣怒马</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/ " alt="home" title="home" itemprop="url">home</a></li><li itemprop="name"><a href="/articles" alt="articles" title="articles" itemprop="url">articles</a></li><li itemprop="name"><a href="/author" alt="author" title="author" itemprop="url">author</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline" class="post-heading">UIImage与RGBA、BGR、GrayScale</h1><span class="post-meta"></span><br><br><p>由于业务需求，CoreDev 封装的 SDK是由C++ OpenCV编写的，需要图片转换成BGR格式。</p>
<p>Demo在<a target="_blank" rel="noopener" href="https://github.com/ColorPenBoy/CPImageColor.git">这里</a></p>
<h4 id="格式类型："><a href="#格式类型：" class="headerlink" title="格式类型："></a>格式类型：</h4><ul>
<li>RBGA -  包含Alpha通道</li>
<li>RGB</li>
<li>BGR</li>
<li>Gray - 灰度图</li>
</ul>
<p>首先理解一张图片的组成，每张图片都是由无数个有序排列的带有颜色的像素点（Pixel）组成的，这些Pixel的排列都可以理解为一个二维数组，每个Pixel都是一个颜色点，即包含RGBA的Pixel。</p>
<h4 id="什么是RGBA呢"><a href="#什么是RGBA呢" class="headerlink" title="什么是RGBA呢"></a>什么是RGBA呢</h4><ul>
<li>R - Red</li>
<li>G - Green</li>
<li>B - Blue</li>
<li>A - Alpha 透明度</li>
</ul>
<h4 id="一个很重要的函数：从函数的命名可以看出，这是一个Bitmap上下文创建函数"><a href="#一个很重要的函数：从函数的命名可以看出，这是一个Bitmap上下文创建函数" class="headerlink" title="一个很重要的函数：从函数的命名可以看出，这是一个Bitmap上下文创建函数"></a>一个很重要的函数：从函数的命名可以看出，这是一个Bitmap上下文创建函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGContextRef __nullable CGBitmapContextCreate(void * __nullable data,</span><br><span class="line">   size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow,</span><br><span class="line">   CGColorSpaceRef __nullable space, uint32_t bitmapInfo)</span><br></pre></td></tr></table></figure>
<p>下面来分别说一下这个函数几个参数的意思：</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>作用、格式</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
<td>用来接收数据</td>
</tr>
<tr>
<td>width</td>
<td>图片宽度</td>
</tr>
<tr>
<td>height</td>
<td>图片高度</td>
</tr>
<tr>
<td>bitsPerComponent</td>
<td>每个Pixel的空间，一般为 8 bit</td>
</tr>
<tr>
<td>bytesPerRow</td>
<td>每行bitmap的字节数，一般为 bitsPerComponent * width</td>
</tr>
<tr>
<td>space</td>
<td>颜色空间(3种：CMYK、RGB、Gray)</td>
</tr>
<tr>
<td>bitmapInfo</td>
<td>bitmap是否应该包含一个阿尔法通道和它是如何产生的,以及是否组件是浮点或整数</td>
</tr>
</tbody></table>
<p>我们主要利用这个函数，来进行下面的转换工作。</p>
<h4 id="将UIImage转为RGBA格式"><a href="#将UIImage转为RGBA格式" class="headerlink" title="将UIImage转为RGBA格式"></a>将UIImage转为RGBA格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (unsigned char *)getRGBAWithImage:(UIImage *)image</span><br><span class="line">&#123;</span><br><span class="line">    int RGBA = 4;</span><br><span class="line">    </span><br><span class="line">    CGImageRef imageRef = [image CGImage];</span><br><span class="line">    </span><br><span class="line">    size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">    size_t height = CGImageGetHeight(imageRef);</span><br><span class="line">    </span><br><span class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    unsigned char *rawData = (unsigned char *) malloc(width * height * sizeof(unsigned char) * RGBA);</span><br><span class="line">    NSUInteger bytesPerPixel = RGBA;</span><br><span class="line">    NSUInteger bytesPerRow = bytesPerPixel * width;</span><br><span class="line">    NSUInteger bitsPerComponent = 8;</span><br><span class="line">    CGContextRef context = CGBitmapContextCreate(rawData, width, height, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    </span><br><span class="line">    CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</span><br><span class="line">    </span><br><span class="line">    CGColorSpaceRelease(colorSpace);</span><br><span class="line">    CGContextRelease(context);</span><br><span class="line">    </span><br><span class="line">    return rawData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="继续上面的工作，获取这张图片中某个Pixel的RGBA值"><a href="#继续上面的工作，获取这张图片中某个Pixel的RGBA值" class="headerlink" title="继续上面的工作，获取这张图片中某个Pixel的RGBA值"></a>继续上面的工作，获取这张图片中某个Pixel的RGBA值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (void)getRGBAFromImage:(UIImage *)image atX:(int)xx andY:(int)yy </span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    int RGBA = 4;</span><br><span class="line">    </span><br><span class="line">    CGImageRef imageRef = [image CGImage];</span><br><span class="line">    size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">    size_t height = CGImageGetHeight(imageRef);</span><br><span class="line">    </span><br><span class="line">    // 从image的data buffer中取得影像，放入格式化后的rawData中</span><br><span class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    unsigned char *rawData = (unsigned char *)malloc(height * width * RGBA);</span><br><span class="line">    NSUInteger bytesPerPixel = RGBA;</span><br><span class="line">    NSUInteger bytesPerRow = bytesPerPixel * width;</span><br><span class="line">    NSUInteger bitsPerComponent = 8;</span><br><span class="line">    </span><br><span class="line">    CGContextRef context = CGBitmapContextCreate(rawData, width, height, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    CGColorSpaceRelease(colorSpace);</span><br><span class="line">    </span><br><span class="line">    // 清空CGContextRef再绘制</span><br><span class="line">    CGContextClearRect(context, CGRectMake(0.0, 0.0, width, height));</span><br><span class="line">    CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</span><br><span class="line">    CGContextRelease(context);</span><br><span class="line">    </span><br><span class="line">    // 将XY坐标转成一维数组</span><br><span class="line">    unsigned long byteIndex = (bytesPerRow * yy) + (bytesPerPixel * xx);</span><br><span class="line">    </span><br><span class="line">    // 取得RGBA位的数据</span><br><span class="line">    CGFloat red   = rawData[byteIndex];</span><br><span class="line">    CGFloat green = rawData[byteIndex + 1];</span><br><span class="line">    CGFloat blue  = rawData[byteIndex + 2];</span><br><span class="line">    CGFloat alpha = rawData[byteIndex + 3];</span><br><span class="line">    </span><br><span class="line">    // 利用RGB计算灰阶的亮度值</span><br><span class="line">    CGFloat gray = (red + green + blue)/3 ;</span><br><span class="line">    </span><br><span class="line">    // 输出</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;%.2f&quot;, red]);</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;%.2f&quot;, green]);</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;%.2f&quot;, blue]);</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;%.2f&quot;, alpha]);</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSString stringWithFormat:@&quot;%.2f&quot;, gray]);</span><br><span class="line">    </span><br><span class="line">    free(rawData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="将图片转为BGR格式"><a href="#将图片转为BGR格式" class="headerlink" title="将图片转为BGR格式"></a>将图片转为BGR格式</h4><p>转换为BGR格式，顾名思义，BGR与RGBA，我们只需要把RGBA数据取到，去掉Alpha，再调换一下RGB的顺序就可以了，下面是具体调换代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (unsigned char *)getBGRWithImage:(UIImage *)image</span><br><span class="line">&#123;</span><br><span class="line">    int RGBA = 4;</span><br><span class="line">    int RGB  = 3;</span><br><span class="line">    </span><br><span class="line">    CGImageRef imageRef = [image CGImage];</span><br><span class="line">    </span><br><span class="line">    size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">    size_t height = CGImageGetHeight(imageRef);</span><br><span class="line">    </span><br><span class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    unsigned char *rawData = (unsigned char *) malloc(width * height * sizeof(unsigned char) * RGBA);</span><br><span class="line">    NSUInteger bytesPerPixel = RGBA;</span><br><span class="line">    NSUInteger bytesPerRow = bytesPerPixel * width;</span><br><span class="line">    NSUInteger bitsPerComponent = 8;</span><br><span class="line">    CGContextRef context = CGBitmapContextCreate(rawData, width, height, bitsPerComponent, bytesPerRow, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);</span><br><span class="line">    </span><br><span class="line">    CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</span><br><span class="line">    </span><br><span class="line">    CGColorSpaceRelease(colorSpace);</span><br><span class="line">    CGContextRelease(context);</span><br><span class="line">    </span><br><span class="line">    unsigned char * tempRawData = (unsigned char *)malloc(width * height * 3 * sizeof(unsigned char));</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; width * height; i ++) &#123;</span><br><span class="line">        </span><br><span class="line">        NSUInteger byteIndex = i * RGBA;</span><br><span class="line">        NSUInteger newByteIndex = i * RGB;</span><br><span class="line">        </span><br><span class="line">        // Get RGB</span><br><span class="line">        CGFloat red    = rawData[byteIndex + 0];</span><br><span class="line">        CGFloat green  = rawData[byteIndex + 1];</span><br><span class="line">        CGFloat blue   = rawData[byteIndex + 2];</span><br><span class="line">        //CGFloat alpha  = rawData[byteIndex + 3];// 这里Alpha值是没有用的</span><br><span class="line">        </span><br><span class="line">        // Set RGB To New RawData</span><br><span class="line">        tempRawData[newByteIndex + 0] = blue;   // B</span><br><span class="line">        tempRawData[newByteIndex + 1] = green;  // G</span><br><span class="line">        tempRawData[newByteIndex + 2] = red;    // R</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return tempRawData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="什么是Gray灰度"><a href="#什么是Gray灰度" class="headerlink" title="什么是Gray灰度"></a>什么是Gray灰度</h4><p>灰度（Gray scale）数字图像是每个像素只有一个采样颜色的图像。这类图像通常显示为从最暗黑色到最亮的白色的灰度</p>
<p>那么如何获取一个Pixel的Gray value呢：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">心理学公式:</span><br><span class="line">	Gray = R * 0.299 + G * 0.587 + B * 0.114</span><br><span class="line"></span><br><span class="line">平均值方法:</span><br><span class="line">    GRAY = (RED + BLUE + GREEN) / 3</span><br><span class="line">   （GRAY,GRAY,GRAY ） 替代 （RED,GREEN,BLUE）</span><br><span class="line">   </span><br><span class="line">位移算法:</span><br><span class="line">	Gray = (R * 19595 + G * 38469 + B * 7472) &gt;&gt; 16</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算机上所有的颜色都可以用这4个数值的组合来表示出来，RGB即为计算机的三原色。</p>
<h4 id="将一张图片转为灰度图"><a href="#将一张图片转为灰度图" class="headerlink" title="将一张图片转为灰度图"></a>将一张图片转为灰度图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (unsigned char *)getGrayWithImage:(UIImage *)image</span><br><span class="line">&#123;</span><br><span class="line">    int GRAY = 1;</span><br><span class="line">    </span><br><span class="line">    // 获取灰度图</span><br><span class="line">    CGImageRef imageRef = [image CGImage];</span><br><span class="line">    </span><br><span class="line">    int width = image.size.width;</span><br><span class="line">    int height = image.size.height;</span><br><span class="line">    unsigned char *rawData = (unsigned char *) malloc(width * height * sizeof(unsigned char));</span><br><span class="line">    </span><br><span class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();</span><br><span class="line">    NSUInteger bytesPerPixel = GRAY;</span><br><span class="line">    NSUInteger bytesPerRow = bytesPerPixel * width;</span><br><span class="line">    NSUInteger bitsPerComponent = 8;</span><br><span class="line">    CGContextRef context = CGBitmapContextCreate(rawData, width, height, bitsPerComponent, bytesPerRow, colorSpace, 0);</span><br><span class="line">    </span><br><span class="line">    CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</span><br><span class="line">    </span><br><span class="line">    CGColorSpaceRelease(colorSpace);</span><br><span class="line">    CGContextRelease(context);</span><br><span class="line">    </span><br><span class="line">    return rawData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参考资料-彦祖分享"><a href="#参考资料-彦祖分享" class="headerlink" title="参考资料(彦祖分享)"></a>参考资料(彦祖分享)</h3><ul>
<li>苹果官方Demo: <a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/samplecode/RosyWriter/Introduction/Intro.html">RosyWriter</a></li>
<li><a target="_blank" rel="noopener" href="https://www.shadertoy.com/">Shadertoy</a></li>
<li><a target="_blank" rel="noopener" href="http://gamedevelopment.tutsplus.com/tutorials/a-beginners-guide-to-coding-graphics-shaders--cms-23313">A Beginner’s Guide to Coding Graphics Shaders</a></li>
<li><a target="_blank" rel="noopener" href="http://codepen.io/">Basic Threejs Scene</a></li>
</ul>
</article><br><br><span class="next-post"><a href="/2015/12/01/2015-12-01-程序员也疯狂—给你的Atom加入炫酷震动效果/" itemprop="url">Older Post ⇒</a></span><span class="prev-post"><a href="/2016/05/09/2016-05-09-tmux/" itemprop="url">⇐ Next Post </a></span><br><br><br></main></body></html>