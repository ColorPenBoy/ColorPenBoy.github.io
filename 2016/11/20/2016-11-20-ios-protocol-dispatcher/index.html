<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Protocol协议分发器(转载) | 彩笔</title><meta name="description"><meta name="generator" content="彩笔"><meta name="author" content="Color Pen"><meta name="keywords"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1><a href="/" alt="彩笔" title="彩笔" itemprop="headline">彩笔</a></h1><p itemprop="description">眼中阅尽繁华，心中鲜衣怒马</p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/ " alt="home" title="home" itemprop="url">home</a></li><li itemprop="name"><a href="/articles" alt="articles" title="articles" itemprop="url">articles</a></li><li itemprop="name"><a href="/author" alt="author" title="author" itemprop="url">author</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline" class="post-heading">Protocol协议分发器(转载)</h1><span class="post-meta"></span><br><br><h1 id="Protocol协议分发器-转载"><a href="#Protocol协议分发器-转载" class="headerlink" title="Protocol协议分发器(转载)"></a>Protocol协议分发器(转载)</h1><p><a target="_blank" rel="noopener" href="http://www.olinone.com/">转自：庞海礁的个人空间 </a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/panghaijiao">原文作者Github</a></p>
<h3 id="何为协议分发？"><a href="#何为协议分发？" class="headerlink" title="何为协议分发？"></a>何为协议分发？</h3><p>协议分发可以简单理解为将协议代理交给多个对象实现！</p>
<p>Protocol协议代理在开发中应用频繁，开发者经常会遇到一个问题——事件的连续传递。比如，为了隔离封装，开发者可能经常会把tableview的delegate或者datesource抽离出独立的对象，而其它对象（比如VC）需要获取某些delegate事件时，只能通过事件的二次传递。有没有更简单的方法了？协议分发器正好可以派上用场。</p>
<p>话不多说，先上干货：<a target="_blank" rel="noopener" href="https://github.com/panghaijiao/HJProtocolDispatcher">HJProtocolDispatcher</a>是一个协议实现分发器，通过该工具能够轻易实现将协议事件分发给多个实现者。比如最常见的tableview的delegate协议，通过<a target="_blank" rel="noopener" href="https://github.com/panghaijiao/HJProtocolDispatcher">HJProtocolDispatcher</a>，能够非常容易的分发给多个对象，具体可参考<a target="_blank" rel="noopener" href="https://github.com/panghaijiao/HJProtocolDispatcher">Demo</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.tableView.delegate = AOProtocolDispatcher(UITableViewDelegate, self, self.delegateSource);</span><br></pre></td></tr></table></figure>

<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p>原理并不复杂， 协议分发器Dispatcher并不实现Protocol协议，其只需将对应的Protocol事件分发给不同的实现者Implemertor。如何实现分发？</p>
<p>熟悉类Class响应链的童鞋都知道，NSObject对象主要通过以下函数响应未实现的Selector函数调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0);</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation OBJC_SWIFT_UNAVAILABLE(&quot;&quot;);</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>
<p>因此，协议分发器Dispatcher可以在该函数中将Protocol中Selector的调用传递给实现者Implemertor，由实现者Implemertor实现具体的Selector函数即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    SEL aSelector = anInvocation.selector;</span><br><span class="line">    if (!ProtocolContainSel(self.prococol, aSelector)) &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (ImplemertorContext *implemertorContext in self.implemertors) &#123;</span><br><span class="line">        if ([implemertorContext.implemertor respondsToSelector:aSelector]) &#123;</span><br><span class="line">            [anInvocation invokeWithTarget:implemertorContext.implemertor];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计关键"><a href="#设计关键" class="headerlink" title="设计关键"></a>设计关键</h3><p>如何做到只对Protocol中Selector函数的调用做分发是设计的关键，系统提供有函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)</span><br></pre></td></tr></table></figure>

<p>通过以下方法即可判断Selector是否属于某一Protocol</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method_description MethodDescriptionForSELInProtocol(Protocol *protocol, SEL sel) &#123;</span><br><span class="line">    struct objc_method_description description = protocol_getMethodDescription(protocol, sel, YES, YES);</span><br><span class="line">    if (description.types) &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;</span><br><span class="line">    description = protocol_getMethodDescription(protocol, sel, NO, YES);</span><br><span class="line">    if (description.types) &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;</span><br><span class="line">    return (struct objc_method_description)&#123;NULL, NULL&#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">BOOL ProtocolContainSel(Protocol *protocol, SEL sel) &#123;</span><br><span class="line">    return MethodDescriptionForSELInProtocol(protocol, sel).types ? YES: NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>协议分发器使用需要了解如何处理带有返回值的函数 ，比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section</span><br></pre></td></tr></table></figure>
<p>我们知道，iOS中，函数执行返回的结果存在于寄存器R0中，后执行的会覆盖先执行的结果。因此，当遇到有返回结果的函数时，返回结果以后执行的函数返回结果为最终值，以Demo为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.tableView.delegate = AOProtocolDispatcher(UITableViewDelegate, self, self.delegateSource);</span><br></pre></td></tr></table></figure>

<p>TableView的DataSource以后面的self.delegateSource中实现函数返回的结果为准。</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>开发完本项目后发现网上已有朋友实现了协议分发器<a target="_blank" rel="noopener" href="https://github.com/alessandroorru/AOMultiproxier">AOMultiproxier</a>，因此，技术版权属于原作者，本文只做宣传，特此说明！</p>
</article><br><br><span class="next-post"><a href="/2016/07/10/2016-07-10-AFNetworking-1/" itemprop="url">Older Post ⇒</a></span><span class="prev-post"><a href="/2016/12/08/2016-12-08-functional_programming_currying/" itemprop="url">⇐ Next Post </a></span><br><br><br></main></body></html>